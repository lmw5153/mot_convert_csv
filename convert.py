# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jc-gxQtQwRn_g4hp2efMuRocOSDm1-v2
"""

# app.py
# Streamlit ì›¹ì•±: OpenCap .mot/.sto â†’ CSV ë³€í™˜ + ë³‘í•©
# pip install streamlit pandas numpy

import io
import re
import zipfile
from datetime import datetime
from typing import Tuple, List, Dict

import numpy as np
import pandas as pd
import streamlit as st


st.set_page_config(page_title="OpenCap MOT â†’ CSV ë³€í™˜ê¸°", page_icon="ğŸš¶", layout="wide")

st.title("ğŸš¶ OpenCap MOT â†’ CSV ë³€í™˜ê¸°")
st.write("ì—¬ëŸ¬ ê°œì˜ .mot/.sto íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ CSVë¡œ ë³€í™˜í•©ë‹ˆë‹¤. â€˜ë³‘í•©â€™ ê¸°ëŠ¥ìœ¼ë¡œ íŒŒì¼ëª…(=ID) ê¸°ì¤€ ì„¸ë¡œ ë³‘í•©ë„ ì§€ì›í•©ë‹ˆë‹¤. (OpenSim ì„¤ì¹˜ ë¶ˆí•„ìš”)")
st.write("íŒŒì¼ì„ ë°‘ì— ë°°ë„ˆì— ë“œë˜ê·¸ í•´ì£¼ì„¸ìš”!")
st.caption("mimic")
# ---------------------------
# ìœ í‹¸: .mot/.sto í—¤ë” íŒŒì‹± & ë³¸ë¬¸ ì½ê¸°
# ---------------------------
def parse_opensim_table(file_bytes: bytes) -> Tuple[pd.DataFrame, Dict[str, str]]:
    """
    OpenSim .mot/.sto íŒŒì¼ì„ í…ìŠ¤íŠ¸ë¡œ íŒŒì‹±í•˜ì—¬ pandas DataFrameìœ¼ë¡œ ë°˜í™˜.
    í—¤ë” ë©”íƒ€ì •ë³´(í‚¤:ê°’)ë¥¼ dictë¡œ í•¨ê»˜ ë°˜í™˜.
    ê·œì¹™:
      - 'endheader' ì¤„ ì´í›„ë¶€í„° ë°ì´í„° ì˜ì—­
      - ê³µë°±/íƒ­ êµ¬ë¶„
      - ì²« ì»¬ëŸ¼(ëŒ€ê°œ time)ì„ ì¸ë±ìŠ¤ ì§€ì •í•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ìœ ì§€
    """
    text = file_bytes.decode("utf-8", errors="ignore")
    lines = text.splitlines()

    header_meta = {}
    header_end_idx = None
    for i, line in enumerate(lines):
        if line.strip().lower() == "endheader":
            header_end_idx = i
            break
        # í‚¤:ê°’ í˜•íƒœ ë©”íƒ€ íŒŒì‹±
        if ":" in line:
            k, v = line.split(":", 1)
            header_meta[k.strip()] = v.strip()

    if header_end_idx is None:
        # .mot/.sto ì¤‘ ì¼ë¶€ëŠ” 'endheader' ì—†ì´ íƒ­/ê³µë°± í—¤ë”ê°€ ë°”ë¡œ ë‚˜ì˜¬ ìˆ˜ë„ ìˆìŒ â†’ íœ´ë¦¬ìŠ¤í‹±
        # ì²« ë°ì´í„° ë¼ì¸ ì¶”ì •: ìˆ«ìë¡œ ì‹œì‘í•˜ëŠ” ì²« ì¤„ ì¸ë±ìŠ¤
        header_end_idx = 0
        for i, line in enumerate(lines):
            if re.match(r"^\s*[-+]?(\d+(\.\d+)?([eE][-+]?\d+)?)", line.strip()):
                header_end_idx = i - 1
                break

    # ë°ì´í„° ì˜ì—­ í…ìŠ¤íŠ¸ë¡œ ì¬ì¡°í•©
    data_text = "\n".join(lines[header_end_idx + 1 :])

    # ì»¬ëŸ¼ëª… ë¼ì¸ ì¶”ì •: ë°ì´í„° ì²« ì¤„ì´ ìˆ«ìë©´, ê·¸ ìœ—ì¤„ì´ ì»¬ëŸ¼ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìŒ
    # pandasì— ë°”ë¡œ ë˜ì ¸ë³´ê³ , ì „ë¶€ ìˆ«ìì´ë©´ í—¤ë” ì—†ìŒìœ¼ë¡œ ê°„ì£¼ í›„ ë‹¤ì‹œ ì‹œë„
    try:
        df_try = pd.read_csv(io.StringIO(data_text), delim_whitespace=True)
        # í—¤ë”ê°€ ì—†ëŠ” ê²½ìš°(ì²« í–‰ì´ ìˆ«ìë¡œë§Œ êµ¬ì„±) â†’ names ì—†ì´ ë‹¤ì‹œ ì‹œë„
        if all(str(c).replace(".", "", 1).isdigit() for c in df_try.columns[:2]):
            df = pd.read_csv(io.StringIO(data_text), delim_whitespace=True, header=None)
        else:
            df = df_try
    except Exception:
        # ê³µë°±ì´ ì•„ë‹Œ íƒ­ìœ¼ë¡œë§Œ êµ¬ë¶„ë˜ì–´ ìˆì„ ìˆ˜ë„ ìˆìŒ
        df = pd.read_csv(io.StringIO(data_text), sep=r"[\t\s]+", engine="python", header=None)

    # ì»¬ëŸ¼ëª… ë³´ì •: í—¤ë” ë¼ì¸ì´ í•˜ë‚˜ ë” ìˆì„ ìˆ˜ ìˆìŒ (ë¬¸ì+ìˆ«ì í˜¼ì¬)
    # ì²« í–‰ì´ ë¬¸ìì—´ë¡œë§Œ êµ¬ì„±ë¼ìˆìœ¼ë©´ ì»¬ëŸ¼ìœ¼ë¡œ ìŠ¹ê²©
    if df.shape[0] > 1:
        first_row = df.iloc[0].astype(str).tolist()
        if all(re.search(r"[A-Za-z_]", s) for s in first_row):
            df.columns = first_row
            df = df.iloc[1:].reset_index(drop=True)

    # time ì»¬ëŸ¼ í‘œì¤€í™” (ìˆë‹¤ë©´ floatë¡œ)
    for cand in ["time", "Time", "t", "Time(s)"]:
        if cand in df.columns:
            df.rename(columns={cand: "time"}, inplace=True)
            break

    if "time" in df.columns:
        with np.errstate(all="ignore"):
            df["time"] = pd.to_numeric(df["time"], errors="coerce")

    # ìˆ«ìí˜•ìœ¼ë¡œ ë°”ê¿€ ìˆ˜ ìˆëŠ” ì»¬ëŸ¼ì€ ê°€ê¸‰ì  ìˆ«ìë¡œ
    for c in df.columns:
        if c == "time":
            continue
        df[c] = pd.to_numeric(df[c], errors="ignore")

    return df, header_meta


def sanitize_id_from_filename(name: str) -> str:
    base = re.sub(r"\.mot$|\.sto$|\.txt$|\.csv$", "", name, flags=re.IGNORECASE)
    base = re.sub(r"[^\w\-]+", "_", base).strip("_")
    return base or "ID"


# ---------------------------
# ì‚¬ì´ë“œë°”: ì˜µì…˜
# ---------------------------
st.sidebar.header("ì˜µì…˜")
merge_on = st.sidebar.checkbox("ì—¬ëŸ¬ íŒŒì¼ ë³‘í•©(íŒŒì¼ëª…=ID)", value=True)
id_column_name = st.sidebar.text_input("ID ì»¬ëŸ¼ëª…", value="ID")
time_round = st.sidebar.selectbox("time ë°˜ì˜¬ë¦¼(ì˜µì…˜)", options=["ê·¸ëŒ€ë¡œ", "ì†Œìˆ˜ì  3ìë¦¬", "ì†Œìˆ˜ì  4ìë¦¬"], index=0)
zip_prefix = st.sidebar.text_input("ë‹¤ìš´ë¡œë“œ ZIP/CSV ì´ë¦„ ì ‘ë‘ì‚¬", value="opencap")

st.sidebar.markdown("---")
st.sidebar.caption("íŒŒì¼ëª… ì¤‘ë³µ ì‹œ ìë™ìœ¼ë¡œ `_2`, `_3`ë¥¼ IDì— ë¶€ì—¬í•©ë‹ˆë‹¤.")


# ---------------------------
# ë³¸ë¬¸: ì—…ë¡œë“œ
# ---------------------------
files = st.file_uploader(
    "ì—¬ëŸ¬ ê°œì˜ .mot/.sto íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì„¸ìš”",
    type=["mot", "sto"],
    accept_multiple_files=True
)

btn_convert = st.button("ğŸ”„ ë³€í™˜ ì‹¤í–‰ (CSV ìƒì„±)")
btn_merge   = st.button("ğŸ“ ë³‘í•© CSV ë§Œë“¤ê¸°", disabled=(not merge_on))

out_individual: List[Tuple[str, bytes]] = []  # (filename, csv_bytes)
merged_df: pd.DataFrame = pd.DataFrame()


def apply_time_round(df: pd.DataFrame) -> pd.DataFrame:
    if "time" not in df.columns:
        return df
    if time_round == "ì†Œìˆ˜ì  3ìë¦¬":
        df["time"] = df["time"].round(3)
    elif time_round == "ì†Œìˆ˜ì  4ìë¦¬":
        df["time"] = df["time"].round(4)
    return df


# ---------------------------
# ì²˜ë¦¬ ë¡œì§
# ---------------------------
if files and (btn_convert or btn_merge):
    id_counts: Dict[str, int] = {}

    merged_rows = []
    with st.spinner("íŒŒì¼ ì²˜ë¦¬ ì¤‘..."):
        for up in files:
            raw = up.read()
            try:
                df, meta = parse_opensim_table(raw)
            except Exception as e:
                st.error(f"âŒ íŒŒì‹± ì‹¤íŒ¨: {up.name} â€” {e}")
                continue

            df = apply_time_round(df)

            # ê°œë³„ CSV
            csv_bytes = df.to_csv(index=False).encode("utf-8-sig")
            out_individual.append((f"{sanitize_id_from_filename(up.name)}.csv", csv_bytes))

            if merge_on:
                # íŒŒì¼ëª… â†’ ID
                _id = sanitize_id_from_filename(up.name)
                # ì¤‘ë³µ ì²˜ë¦¬
                if _id in id_counts:
                    id_counts[_id] += 1
                    _id = f"{_id}_{id_counts[_id]}"
                else:
                    id_counts[_id] = 1

                # ë³‘í•©ìš©: ë§¨ ì•ì— ID ì»¬ëŸ¼ ì¶”ê°€
                df_ = df.copy()
                df_.insert(0, id_column_name, _id)
                merged_rows.append(df_)

    # ë‹¤ìš´ë¡œë“œ ì„¹ì…˜
    st.subheader("ğŸ“¥ ë‹¤ìš´ë¡œë“œ")

    # (1) ê°œë³„ CSV â†’ ZIP
    if out_individual:
        zip_buf = io.BytesIO()
        with zipfile.ZipFile(zip_buf, "w", compression=zipfile.ZIP_DEFLATED) as zf:
            for fname, b in out_individual:
                zf.writestr(fname, b)
        zip_name = f"{zip_prefix}_csv_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
        st.download_button(
            "ê°œë³„ CSV (ZIP) ë‹¤ìš´ë¡œë“œ",
            data=zip_buf.getvalue(),
            file_name=zip_name,
            mime="application/zip"
        )

    # (2) ë³‘í•© CSV
    if merge_on and merged_rows:
        merged_df = pd.concat(merged_rows, ignore_index=True)
        # time ì»¬ëŸ¼ì´ ìˆìœ¼ë©´ ì •ë ¬(ì„ íƒ)
        if "time" in merged_df.columns:
            merged_df.sort_values([id_column_name, "time"], inplace=True)
        csv_merged = merged_df.to_csv(index=False).encode("utf-8-sig")
        csv_name = f"{zip_prefix}_merged_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        st.download_button(
            "ë³‘í•© CSV ë‹¤ìš´ë¡œë“œ",
            data=csv_merged,
            file_name=csv_name,
            mime="text/csv"
        )

    # ë¯¸ë¦¬ë³´ê¸°
    if out_individual:
        st.markdown("---")
        st.subheader("ğŸ‘€ ë¯¸ë¦¬ë³´ê¸°")
        # ì²« ë²ˆì§¸ íŒŒì¼ë§Œ ì‚´ì§ ë³´ì—¬ì£¼ê¸°
        try:
            preview_df, _ = parse_opensim_table(files[0].getvalue())
            st.dataframe(preview_df.head(20), use_container_width=True)
        except Exception:
            pass

elif not files:
    st.info("ì¢Œì¸¡ ë˜ëŠ” ìœ„ì˜ ì˜ì—­ì—ì„œ .mot/.sto íŒŒì¼ì„ í•˜ë‚˜ ì´ìƒ ì—…ë¡œë“œí•˜ì„¸ìš”.")
